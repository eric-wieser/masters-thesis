\providecommand{\thebibpath}{..}
\makeatletter\def\input@path{{\thebibpath/}{.}}\makeatother
\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Changing platform}

	The inherited embedded software required a toolchain called MPIDE (a fork of an early version of the Arduino IDE), which to quote the authors \enquote{is no longer being maintained, and is quickly falling behind} \cite{ mpide}, as of January 2016. This is troublesome, as at some point in future, it may become impossible to download the software, which would make our embedded code unusable - better to deal with this technical debt now. The replacement software is an extension (\texttt{chipkit-core}) for the standard Arduino IDE.

	Unfortunately, this change in tools also comes with a change in hardware libraries.
	Due to license incompatibilities, the \texttt{plib} library bundled with MPIDE, which we were making use of to operate hardware registers, is not available in the Arduino IDE.
	This meant that large amounts of code that interfaced with hardware had to change. Many of these changes involves switching to the stardard Arduino constructs for setting interrupts and writing pins.
	The rest required the use of features of the \texttt{chipkit-core} library.

	To verify that the transition was made correctly, some simple tests were performed with the motors, encoder, and accelerometer readings, all of which are easy to verify a log stream against by eye. One such mistake this picked up was that the encoders were no longer changing sign correcty.
	This was due to confusion\footnotemark between interrupt \emph{numbers} (referred to as \texttt{IRQ}s in the library) and interrupt \emph{vectors}.

	\footnotetext{A type of mistake that well-typed code written in C++, rather than C, would have prevented from happening in the first place. Alas, C is here to stay in the realm of embedded software libraries.}

	While the Arduino IDE family has the benefits of being widely-used, active, and open source, it has a bad approach to dependency management, which in practice makes it difficult to create small reusable components.
	To give an example, the following dependency structure is difficult for an Arduino project to handle:
	\begin{itemize}[noitemsep]
		\item The application depends on library \texttt{A} and \texttt{B}
		\item Library \texttt{B} depends on \texttt{C}
	\end{itemize}
	Worse yet, even if we remove the dependency on \texttt{C}, it is very difficult to distribute \texttt{A} alongside our application.

	There is a open source project that acknowledges and provides a solution to these shortcomings, PlatformIO \cite{platformio}.
	This keeps the excellent cross-platform support that the arduino libraries provide, and pairs them with a package manager, and a command line tool.
	One particularly useful feature is the ability to run unit tests on the arduino, to verify the correctness of software.

\subsection{Building a communication interface}

	In the review of the current system, we noted that the current system to configure the robot is manual and error prone.
	Echoing Aleki's \cite[p.~34]{aleksi} remarks, a worthwhile next step would be \enquote{automatically writing the policy parameters to the microcontroller program from Matlab as well as [adding] a direct serial communication between Matlab and the unicycle for data exchange}.

	The approach taken here unifies the above two suggestions.
	The goal is to have the program on the robot be static, and have it be reconfigurable over the serial link, as well as using that link to send back structured data.
	To achieve this, a communication protocol for sending structured messages must be designed. This breaks down into two parts:
	\begin{itemize}[noitemsep]
		\item Serialization (\enquote{structured}) -– converting an arbitrary data model into a series of bytes, and back again
		\item Framing (\enquote{messages}) –- distinguishing where one message begins and another ends
	\end{itemize}
	Both of these can be hard problems to get right, and so reinventing the wheel should be avoided.

	\subsubsection{Serialization}
		Google’s \enquote{Protocol Buffers}\cite{protobuf} (or simply \enquote{protobuf}) are a popular framework for implementing serialization, which are used extensively within Google, and have cross-language support.
		This framework requires a \texttt{.proto} file to be specified, like the following excerpt of our \texttt{messaging.proto}:
		\begin{lstlisting}[gobble=4]
		// Not shown: definitions of DebugLevel, LogBundle, and LogEntry
		syntax = "proto3";
		message DebugMessage {
			string s = 1;
			DebugLevel level = 2;
		}
		message RobotMessage {
			oneof msg {
				LogBundle log_bundle = 1;
				DebugMessage debug = 2;
				LogEntry single_log = 3;
			}
		}
		\end{lstlisting}
		From this file, C++ and Python code can be generated to serialize and deserialize these messages into native types.
		An implementation of this for embedded C, with small code size and no heap allocation, exists as the Nanopb project \cite{nanopb}, which thanks to our switch to PlatformIO \cref{section:TODO}, is easy to include on our robot.

		Unfortunately, there is no first-party support of protobuf in Matlab, and the only available third-party implementation \cite{protobuf-matlab} is difficult to install, and abandonware.\footnotemark

		\footnotetext{
			The API of protobuf has changed significantly in the 5 years since this package was last modified.
			As such, if using protobuf from matlab is desired in future, I would recommend starting the implementation from scratch as a protobuf python plugin, using the latest google developer examples.
		}

	\subsubsection{Framing}

		It's worth recapping what level of abstraction the USB serial link exposes.
		Serial links allow a sequence of bytes to be sent one after another down a transmit (\texttt{tx}) channel, while at the same time a sequence of bytes are appear on the receive (\texttt{rx}) channel. The users of such a channel do not need to concern themselves with raw bits. There are two important properties to note here:
		\begin{itemize}[noitemsep]
			\item
				The receiver has to handle the byte as soon as it appears on the receive channel, as the channel has no memory.
				The typical approach is to add this byte to a queue or buffer, such that it can be processed later.
				This only delays the problem though -- this queue can become full, and subsequent bytes will be lost.
			\item
				Unlike I\textsuperscript{2}C, the channel provides no mechanism to group a set of bytes together.
				Every byte is sent separately, and in practice, implementations do not record at what time each byte was recieved (ruling out using a time delay to indicate \enquote{end-of-group}).
		\end{itemize}

		The problem of \enquote{framing}, then is build on this abstraction to provide a mechanism to group bytes together into packets. Consider the sequence of packets
		\enquote{\texttt{F1}\,\texttt{00}\,\texttt{DS}},
		\enquote{\texttt{0F}},
		\enquote{\texttt{C0}\,\texttt{FF}\,\texttt{EE}}, shown with each byte in hexadecimal notation.
		A na\"ive approach is to prefix a chunk of bytes by its length, giving
		\mbox{\enquote{%
			\textbf{\texttt{03}}\,\texttt{F1}\,\texttt{00}\,\texttt{DS}\,%
			\textbf{\texttt{01}}\,\texttt{0F}\,%
			\textbf{\texttt{03}}\,\texttt{C0}\,\texttt{FF}\,\texttt{EE}%
		}}, with inserted bytes shown in bold.
		To see why this is not enough, consider what happens if the\,\texttt{F1} byte does not fit in the buffer and is discarded. The receiver now sees \mbox{\enquote{%
			\textbf{\texttt{03}}\,\texttt{00}\,\texttt{DS}\,\texttt{01}\,%
			\textbf{\texttt{0F}}\,\texttt{03}\,\texttt{C0}\,\texttt{FF}\,\texttt{EE}\,%
			...%
		}} -- corruption in the first packet has corrupted the following two packets, and possibly the rest of the stream for all time!

		A good solution to this problem is COBS, which to quote the originating paper \cite{cobs}, \enquote{allows new listeners to join a broadcast stream at any time and without fail receive and decode the very next error free packet} -- ideal for our scenario where the serial USB connection is plugged and unplugged (\cref{sec:untethered}). Under COBS, the example packets are encoded as
		\mbox{\enquote{%
			\textit{\texttt{02}}\,\texttt{F1}\,\textit{\texttt{02}}\,\texttt{DS}\,\textbf{\texttt{00}}\,%
			\textit{\texttt{02}}\,\texttt{0F}\,\textbf{\texttt{00}}\,%
			\textit{\texttt{04}}\,\texttt{C0}\,\texttt{FF}\,\texttt{EE}\,\textbf{\texttt{00}}%
		}}, with \textbf{\texttt{00}} bytes appear only at the end of each packet.
		The italic inserted bytes encode zeros within packets by counting the number of bytes until the next zero.
		Using this method, dropping any non-zero byte will corrupt only a single packet, and dropping a zero byte will corrupt only two packets.

		Sadly, no implementation of COBS was available for the Arduino which was suitable for use with Nanopb\footnotemark.
		Messaging over serial is an essential part of many Arduino projects, and so the inability to assemble a robust messaging stack from library code is cause for alarm.
		In the interest of giving back to the community, I published PacketIO \cite{packetio}, a package to solve the framing problem.
		This package includes unit tests and online documentation, in order to help verify its correctness and encourage its use.

		\footnotetext{
			A package implementing COBS for Arduino does exist, PacketSerial\cite{packetserial}.
			However, this requires the entire message to be calculated before any of it is sent, whereas nanopb requires a streaming protocol. Nanopb's choice makes it able to write arbitrarily large messages piece by piece -- such as our state logs.
		}

	\subsubsection{Using the protocol}

		With a messaging interface on the robot, a tool was needed on the PC to communicate with it.
		Due to the previously-mentioned lack of protobuf implementation in Matlab, Python 3.5 was chosen as the tool for the job.

		For simplicity, the tool was created as an interactive command-line application, rather than a GUI.
		A screenshot of the interface is shown in \cref{TODO}.
		From this command line, commands can be sent to and data collected from the robot.
		Of particular note is that any diagnostic messages from the robot also appear in this interface, as they too go through the messaging interface.

		The key command in this program is \texttt{go 50}, which sets up a 50-timestep rollout.
		Once run, the robot can be detached, and the rollout begun.
		The command-line application waits for the robot to be reattached, and then extracts the state logs, dumping them into a \texttt{.mat} file for the PILCO Matlab code to read.


\bib

\end{document}
